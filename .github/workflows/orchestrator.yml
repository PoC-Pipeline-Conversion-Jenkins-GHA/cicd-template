# This is the main orchestrator (or "router") workflow.
# It defines the 5 stages (Build, Test, Scan, Sign, Deploy)
# and uses 'needs:' to create dependencies.
# It uses 'if:' to fan-out to the correct technology-specific workflow.
name: Central CI Orchestrator

on:
  workflow_call:
    # 1. It accepts the 'pipeline_profile' from the application repo
    inputs:
      pipeline_profile:
        description: 'The technology profile to run (e.g., java-openshift, dotnet, Android, tomcat)'
        type: string
        required: true
      
      # 2. It accepts all other parameters to pass-through
      sonar-project-key:
        type: string
      snyk-org-slug:
        type: string

      runner-label:
        description: 'The label of the runner to use (e.g., ubuntu-latest, self-hosted)'
        type: string
        required: false
        default: 'ubuntu-latest' # Provide a safe default
      artifact-name:
        type: string
        required: false
        default: "mi-aplicacion-web-war"
      java-version:
        type: string
        required: false
        default: "17"
      tomcat-host:
        type: string
        required: false
      tomcat-user:
        type: string
        required: false
      target-war-name:
        type: string
        required: false
      tomcat-webapps-path:
        type: string
        required: false

    # 3. It accepts all secrets to pass-through
    secrets:
      SONAR_TOKEN:
        required: false
      SNYK_TOKEN:
        required: false
      SIGNING_KEY:
        required: false
      OPENSHIFT_TOKEN:
        required: false
      SSH_PRIVATE_KEY:
        required: false

jobs:
  # ===================================================
  # STAGE 1: BUILD
  # ===================================================
  build-java:
    name: "1. Build (Java)"
    if: |
      inputs.pipeline_profile == 'java-openshift' ||
      inputs.pipeline_profile == 'java-middlewares'
    uses: ./.github/workflows/build-java.yml
    with:
      runner-label: ${{ inputs.runner-label }}
    secrets: inherit # Passes secrets from on.workflow_call

  build-tomcat:
    name: "1. Build (Tomcat)"
    if: |
      inputs.pipeline_profile == 'tomcat'
    uses: ./.github/workflows/build-java-war.yml
    with:
      artifact-name: ${{ inputs.artifact-name }}
      java-version: ${{ inputs.java-version }}
      with:
        runner-label: ${{ inputs.runner-label }}
    secrets: inherit # Passes secrets from on.workflow_call

  # build-dotnet:
  #   name: "1. Build (.NET)"
  #   if: inputs.pipeline_profile == '.Net'
  #   uses: ./.github/workflows/build-dotnet.yml
  #   secrets: inherit

  # build-android:
  #   name: "1. Build (Android)"
  #   if: inputs.pipeline_profile == 'Android'
  #   uses: ./.github/workflows/build-android.yml
  #   secrets: inherit

  # ===================================================
  # STAGE 2: TEST
  # ===================================================
  test-java:
    name: "2. Test (Java)"
    needs: [build-java] # Depends on the correct build job
    if: |
      inputs.pipeline_profile == 'java-openshift' ||
      inputs.pipeline_profile == 'java-middlewares'
    uses: ./.github/workflows/test-java.yml
    secrets: inherit

  # test-dotnet:
  #   name: "2. Test (.NET)"
  #   needs: [build-dotnet]
  #   if: inputs.pipeline_profile == '.Net'
  #   uses: ./.github/workflows/test-dotnet.yml
  #   secrets: inherit
  
  # (etc. for Android)

  # ===================================================
  # STAGE 3: SCAN
  # ===================================================
  # scan-java:
  #   name: "3. Scan (Java)"
  #   needs: [test-java] # Depends on the test job
  #   permissions:
  #     security-events: write # Required to upload SARIF results
  #     contents: read
  #   if: |
  #     inputs.pipeline_profile == 'java-openshift' ||
  #     inputs.pipeline_profile == 'java-middlewares'
  #   uses: ./.github/workflows/scan-java.yml
  #   with:
  #     sonar-project-key: ${{ inputs.sonar-project-key }}
  #     snyk-org-slug: ${{ inputs.snyk-org-slug }}
  #   secrets:
  #     # Pass only the specific secrets needed
  #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  #     SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # scan-dotnet:
  #   name: "3. Scan (.NET)"
  #   needs: [test-dotnet]
  #   permissions:
  #     security-events: write
  #     contents: read
  #   if: inputs.pipeline_profile == '.Net'
  #   uses: ./.github/workflows/dotnet-scan.yml
  #   # (pass inputs and secrets)
  #   secrets: inherit

  # ===================================================
  # STAGE 4: SIGN
  # ===================================================
  # sign:
  #   name: "4. Sign Artifact"
  #   # This job is a "fan-in" point. It runs after all
  #   # relevant scan jobs have completed.
  #   needs: [scan-java, scan-dotnet]
  #   # 'if: always()' ensures this job runs to report failure,
  #   # but 'needs' ensures it only proceeds if upstream jobs passed.
  #   # A more robust check is 'if: success() || failure()'
  #   if: success()
  #   permissions:
  #     id-token: write # Required for keyless signing
  #     packages: write
  #   uses: ./.github/workflows/sign-artifact.yml
  #   with:
  #     # You would need logic here to determine which artifact to sign,
  #     # e.g., pass an image-ref from the build stage.
  #     image-ref: 'ghcr.io/my-org/my-app:${{ github.sha }}'
  #   secrets: inherit

  # ===================================================
  # STAGE 5: DEPLOY
  # ===================================================
  # deploy-java-openshift:
  #   name: "5. Deploy (Java OpenShift)"
  #   needs: [sign] # Depends on the 'sign' stage
  #   if: inputs.pipeline_profile == 'java-openshift'
  #   uses: ./.github/workflows/deploy-java-openshift.yml
  #   secrets:
  #     OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}

  # deploy-middleware-nginx:
  #   name: "5. Deploy (Nginx)"
  #   needs: [sign]
  #   if: inputs.pipeline_profile == 'middleware:Nginx'
  #   uses: ./.github/workflows/deploy-middleware-nginx.yml
  #   secrets: inherit # (e.g., SSH_KEY)
  deploy-tomcat:
    name: "5. Deploy to Tomcat"
    needs: [build-tomcat] # Or the previous stage
    if: inputs.pipeline_profile == 'tomcat'
    # Call the child workflow (the Tomcat deployer)
    uses: ./.github/workflows/deploy-tomcat-ssh.yml
    # The 'with:' section maps the inputs
    with:
      # Mapping: <child_input> : <value_received_by_orchestrator>
      runner-label: ${{ inputs.runner-label }}
      artifact-name: ${{ inputs.project-name }}-war
      tomcat-host: ${{ inputs.tomcat-host }}
      tomcat-user: ${{ inputs.tomcat-user }}
      tomcat-webapps-path: ${{ inputs.tomcat-webapps-path }}
      target-war-name: ${{ inputs.target-war-name }}
      # (tomcat-service-name will use its 'default' in the child)
    # The 'secrets:' section maps the secrets
    secrets:
      # Mapping: <child_secret> : <secret_received_by_orchestrator>
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

  # (etc. for all other deploy profiles)
